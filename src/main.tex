\documentclass[times,specification,annotation]{itmo-student-thesis}

\usepackage{icomma}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{filecontents}
\usepackage{listings}
\usepackage{wrapfig}
\usepackage{biblatex}
\usepackage{pgf}
\usepackage{diagbox}
\begin{filecontents}{reference.bib}
@inproceedings{sta03,
    author={Stam, Martijn},
    editor={Desmedt, Yvo G.},
    title={On Montgomery-Like Representations for Elliptic Curves over GF(2k)},
    booktitle={Public Key Cryptography --- PKC 2003},
    year={2002},
    publisher={Springer Berlin Heidelberg},
    address={Berlin, Heidelberg},
    pages={240--254},
    isbn={978-3-540-36288-3},
    langid={english}
}

@InProceedings{ku02,
author={Ku, Kyo-Min and Ha, Kyeoung-Ju and Kim, Hyun-Sung and Yoo, Kee-Young},
title={New Parallel Architecture for Modular Multiplication and Squaring Based on Cellular Automata},
booktitle={Applied Parallel Computing},
year={2002},
publisher={Springer Berlin Heidelberg},
address={Berlin, Heidelberg},
pages={359--369},
abstract={Modular exponentiation in a finite field is the basic computation involved in most public key crypto systems, such as Diffie-Hellman key exchange, ElGamal, etc. The current paper presents a new parallel architecture whereby the modular multiplication and squaring can be processed simultaneously in GF(2m) in m clock cycles using a cellular automata. Since the proposed cellular automata architecture is simple, regular, modular, cascadable, it can also be utilized efficiently for the implementation of VLSI.},
langid={english}
}

@inproceedings{ku04,
    author = {Ku, KM and Ha, KJ and Yoo, WH and Koo, KY},
    year = {2004},
    month = {01},
    pages = {196-205},
    title = {{Parallel Montgomery multiplication and squaring over GF(2^m) based on cellular automata}},
        langid      = {english},
    isbn = {3-540-22060-7}
}

@inproceedings{mau15,
    author = {Maulana, Mirza and Senjaya, Wenny and Rahardjo, Budi and Muchtadi-Alamsyah, Intan and Paryasto, Marisa},
    year = {2015},
    month = {01},
    pages = {},
    title = {Implementation of Finite Field Arithmetic Operations for Polynomial and Normal Basis Representations},
    doi = {10.2991/iccst-15.2015.25},
    langid = {english}
}

@article{koc97,
    author = {Koc, Cetin and Acar, T.},
    year = {1997},
    month = {01},
    pages = {225},
    title = {Fast Software Exponentiation in GF(2^k)},
    volume = {0},
    isbn = {0-8186-7846-1},
    journal = {Computer Arithmetic, IEEE Symposium on},
        langid      = {english},
    doi = {10.1109/ARITH.1997.614899}
}

@article{koc98,
    author = {Koc, Cetin and Acar, Tolga},
    year = {1998},
    month = {04},
    pages = {57-69},
    title = {Montgomery Multiplication in GF(2k)},
    volume = {14},
    journal = {Designs Codes and Cryptography},
    langid      = {english},
    doi = {10.1023/A:1008208521515}
}

@article{adr15,
    author = {Adrian, David and Bhargavan, Karthikeyan and Durumeric, Zakir and Gaudry, Pierrick and Green, Matthew and Halderman, J. and Heninger, Nadia and Springall, Drew and Thomé, Emmanuel and Valenta, Luke and Vandersloot, Benjamin and Wustrow, Eric and Zanella-Béguelin, Santiago and Zimmermann, Paul},
    year = {2015},
    month = {10},
    pages = {},
    title = {Imperfect Forward Secrecy: How Diffie-Hellman Fails in Practice},
    volume = {62},
    journal = {Communications of the ACM},
    langid = {english},
    doi = {10.1145/3292035}
}

@article{dif77,
  added-at = {2009-01-14T00:43:43.000+0100},
  author = {Diffie, Whitfield and Hellman, Martin E.},
  journal = {IEEE Transactions on Information Theory},
  keywords = {imported},
  month = {November},
  number = 6,
  pages = {644-654},
  timestamp = {2009-01-14T00:43:46.000+0100},
  title = {New Directions in Cryptography},
  topic = {diffiehellman[1]},
  uri = {http://www.cs.purdue.edu/homes/ninghui/courses/Fall04/lectures/diffie-hellman.pdf},
  volume = 22,
    langid      = {english},
  year = 1976
}

@article{zhu17,
    author = {Алексей Евгеньевич Жуков},
    journal = {Вопросы кибербезопасности},
    number = {3 (21)},
    pages = {70-76},
    title = {Клеточные автоматы в криптографии. Часть 1},
    uri = {https://cyberleninka.ru/article/n/kletochnye-avtomaty-v-kriptografii-chast-1},
    langid = {russian},
    doi = {10.21581/2311-3456-2017-3-70-76},
    year = 2017
}

@article{zhu17_2,
    author = {Алексей Евгеньевич Жуков},
    journal = {Вопросы кибербезопасности},
    number = {4 (22)},
    pages = {47-66},
    title = {Клеточные автоматы в криптографии. Часть 2},
    uri = {https://cyberleninka.ru/article/n/kletochnye-avtomaty-v-kriptografii-chast-2},
    langid = {russian},
    doi = {10.21581/2311-3456-2017-4-47-66},
    year = 2017
}

@article{pri16,
  title={Разработка алгебраической библиотеки конечных полей для обобщенных криптографических алгоритмов},
  author={Приньков, АС and Николаев, ДА},
  journal={Международный научно-исследовательский журнал},
  number={7 (49) Часть 4},
  pages={92--94},
  langid = {russian},
  year={2016}
}

@article{jeo07,
    author = {Jeon, Jun-Cheol and Kee-Young, Yoo},
    year = {2007},
    month = {03},
    pages = {915-922},
    title = {Programmable cellular automata based Montgomery hardware architecture},
    volume = {186},
    journal = {Applied Mathematics and Computation},
    langid = {english},
    doi = {10.1016/j.amc.2006.08.018}
}

@article{kri20,
  author  = {Krikun, Alexander and Levina, Alla},
  title   = {Accelerated Diffie–Hellman in GF($2^k$) using parallelized Montgomery exponentiation},
  year    = {Submitted for publication},
  journal = {IEEE Micro},
  langid={english}
}

@book{knu97,
    author = {Knuth, Donald E.},
    title = {The Art of Computer Programming, Volume 1 (3rd Ed.): Fundamental Algorithms},
    year = {1997},
    isbn = {0201896834},
    publisher = {Addison Wesley Longman Publishing Co., Inc.},
    langid      = {english},
    address = {USA}
}

@book{knu97_2,
  added-at = {2015-06-04T07:16:19.000+0200},
  address = {Boston},
  author = {Knuth, Donald E.},
  biburl = {https://www.bibsonomy.org/bibtex/25dbc415549a1bb86bff7a3842765c31f/ytyoun},
  interhash = {b825ccd550f92a93eefbacd1bec78704},
  intrahash = {5dbc415549a1bb86bff7a3842765c31f},
  isbn = {0201896842 9780201896848},
  keywords = {algorithm knuth no.pdf taocp textbook},
  publisher = {Addison-Wesley},
  refid = {174763889},
    langid      = {english},
  timestamp = {2015-07-29T09:31:05.000+0200},
  title = {The Art of Computer Programming, Volume 2 (3rd Ed.): Seminumerical Algorithms},
  year = 1997
}

@book{men01,
  added-at = {2007-04-16T14:16:26.000+0200},
  author = {Menezes, Alfred J. and van Oorschot, Paul C. and Vanstone, Scott A.},
  biburl = {https://www.bibsonomy.org/bibtex/21fb86a3afb62bbb4bc2f94a0299a4d59/kidloc},
  interhash = {d5837a554ce2ffd49f551045400e244c},
  intrahash = {1fb86a3afb62bbb4bc2f94a0299a4d59},
  keywords = {cryptography handbook programming reference security},
  publisher = {CRC Press},
  timestamp = {2007-04-16T14:16:26.000+0200},
  title = {Handbook of Applied Cryptography},
  url = {http://www.cacr.math.uwaterloo.ca/hac/},
  langid = {english},
  year = 2001
}

@book{wol02,
title = {A New Kind of Science},
year = {2002},
isbn = {1579550088},
publisher = {Wolfram Media Inc.},
langid = {english},
address = {Champaign, Ilinois, USA}
}

@book{sma15,
    author = {Smart, Nigel P.},
    title = {Cryptography Made Simple},
    year = {2015},
    isbn = {3319219359},
    publisher = {Springer Publishing Company, Incorporated},
    edition = {1st},
    doi = {10.5555/2927491},
    langid = {english},
}

@book{lev01,
  title={Crypto: How the Code Rebels Beat the Government--Saving Privacy in the Digital Age},
  author={Levy, S.},
  isbn={9781101199466},
  series={Penguin Press Science Series},
  url={https://books.google.ru/books?id=VOxpXwHmQMgC},
  year={2001},
  publisher={Penguin Publishing Group},
  langid={english}
}

@misc{rfc2412,
	series =	{Request for Comments},
	number =	2412,
	howpublished =	{RFC 2412},
	publisher =	{RFC Editor},
	doi =		{10.17487/RFC2412},
	url =		{https://rfc-editor.org/rfc/rfc2412.txt},
    author =	{Hilarie Orman},
	title =		{{The OAKLEY Key Determination Protocol}},
	pagetotal =	55,
	year =		1998,
	month =		nov,
    langid      = {english},
}

@misc{rfc3526,
	series =	{Request for Comments},
	number =	3526,
	howpublished =	{RFC 3526},
	publisher =	{RFC Editor},
	doi =		{10.17487/RFC3526},
	url =		{https://rfc-editor.org/rfc/rfc3526.txt},
    author =	{Mika Kojo and Tero Kivinen},
	title =		{{More Modular Exponential (MODP) Diffie-Hellman groups for Internet Key Exchange (IKE)}},
	pagetotal =	10,
	year =		2003,
	month =		may,
    langid      = {english},
}

@misc{rfc3766,
	series =	{Request for Comments},
	number =	3766,
	howpublished =	{RFC 3766},
	publisher =	{RFC Editor},
	doi =		{10.17487/RFC3766},
	url =		{https://rfc-editor.org/rfc/rfc3766.txt},
        author =	{Paul E. Hoffman and Hilarie Orman},
	title =		{{Determining Strengths For Public Keys Used For Exchanging Symmetric Keys}},
	pagetotal =	23,
	year =		2004,
	month =		apr,
    langid={english},
	abstract =	{Implementors of systems that use public key cryptography to exchange symmetric keys need to make the public keys resistant to some predetermined level of attack. That level of attack resistance is the strength of the system, and the symmetric keys that are exchanged must be at least as strong as the system strength requirements. The three quantities, system strength, symmetric key strength, and public key strength, must be consistently matched for any network protocol usage. While it is fairly easy to express the system strength requirements in terms of a symmetric key length and to choose a cipher that has a key length equal to or exceeding that requirement, it is harder to choose a public key that has a cryptographic strength meeting a symmetric key strength requirement. This document explains how to determine the length of an asymmetric key as a function of a symmetric key strength requirement. Some rules of thumb for estimating equivalent resistance to large-scale attacks on various algorithms are given. The document also addresses how changing the sizes of the underlying large integers (moduli, group sizes, exponents, and so on) changes the time to use the algorithms for key exchange. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.},
}

@misc{rfc4307,
	series =	{Request for Comments},
	number =	4307,
	howpublished =	{RFC 4307},
	publisher =	{RFC Editor},
	doi =		{10.17487/RFC4307},
	url =		{https://rfc-editor.org/rfc/rfc4307.txt},
        author =	{Jeffrey I. Schiller},
	title =		{{Cryptographic Algorithms for Use in the Internet Key Exchange Version 2 (IKEv2)}},
	pagetotal =	6,
	year =		2005,
	month =		dec,
    langid={english},
	abstract =	{The IPsec series of protocols makes use of various cryptographic algorithms in order to provide security services. The Internet Key Exchange (IKE (RFC 2409) and IKEv2) provide a mechanism to negotiate which algorithms should be used in any given association. However, to ensure interoperability between disparate implementations, it is necessary to specify a set of mandatory-to-implement algorithms to ensure that there is at least one algorithm that all implementations will have available. This document defines the current set of algorithms that are mandatory to implement as part of IKEv2, as well as algorithms that should be implemented because they may be promoted to mandatory at some future time. {[}STANDARDS-TRACK{]}},
}

@misc{rfc5246,
	series =	{Request for Comments},
	number =	5246,
	howpublished =	{RFC 5246},
	publisher =	{RFC Editor},
	doi =		{10.17487/RFC5246},
	url =		{https://rfc-editor.org/rfc/rfc5246.txt},
        author =	{Eric Rescorla and Tim Dierks},
	title =		{{The Transport Layer Security (TLS) Protocol Version 1.2}},
	pagetotal =	104,
	year =		2008,
	month =		aug,
    langid={english},
	abstract =	{This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications security over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. {[}STANDARDS-TRACK{]}},
}

@misc{rfc7296,
	series =	{Request for Comments},
	number =	7296,
	howpublished =	{RFC 7296},
	publisher =	{RFC Editor},
	doi =		{10.17487/RFC7296},
	url =		{https://rfc-editor.org/rfc/rfc7296.txt},
    author =	{Charlie Kaufman and Paul E. Hoffman and Yoav Nir and Pasi Eronen and Tero Kivinen},
	title =		{{Internet Key Exchange Protocol Version 2 (IKEv2)}},
	pagetotal =	142,
	year =		2014,
	month =		oct,
    langid      = {english},
}

@misc{rfc7919,
	series =	{Request for Comments},
	number =	7919,
	howpublished =	{RFC 7919},
	publisher =	{RFC Editor},
	doi =		{10.17487/RFC7919},
	url =		{https://rfc-editor.org/rfc/rfc7919.txt},
        author =	{Daniel Kahn Gillmor},
	title =		{{Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)}},
	pagetotal =	29,
	year =		2016,
	month =		aug,
    langid = {english},
	abstract =	{Traditional finite-field-based Diffie-Hellman (DH) key exchange during the Transport Layer Security (TLS) handshake suffers from a number of security, interoperability, and efficiency shortcomings. These shortcomings arise from lack of clarity about which DH group parameters TLS servers should offer and clients should accept. This document offers a solution to these shortcomings for compatible peers by using a section of the TLS "Supported Groups Registry" (renamed from "EC Named Curve Registry" by this document) to establish common finite field DH parameters with known structure and a mechanism for peers to negotiate support for these groups. This document updates TLS versions 1.0 (RFC 2246), 1.1 (RFC 4346), and 1.2 (RFC 5246), as well as the TLS Elliptic Curve Cryptography (ECC) extensions (RFC 4492).},
}

@misc{rfc8247,
	series =	{Request for Comments},
	number =	8247,
	howpublished =	{RFC 8247},
	publisher =	{RFC Editor},
	doi =		{10.17487/RFC8247},
	url =		{https://rfc-editor.org/rfc/rfc8247.txt},
        author =	{Yoav Nir and Tero Kivinen and Paul Wouters and Daniel Migault},
	title =		{{Algorithm Implementation Requirements and Usage Guidance for the Internet Key Exchange Protocol Version 2 (IKEv2)}},
	pagetotal =	19,
	year =		2017,
	month =		sep,
    langid={english},
	abstract =	{The IPsec series of protocols makes use of various cryptographic algorithms in order to provide security services. The Internet Key Exchange (IKE) protocol is used to negotiate the IPsec Security Association (IPsec SA) parameters, such as which algorithms should be used. To ensure interoperability between different implementations, it is necessary to specify a set of algorithm implementation requirements and usage guidance to ensure that there is at least one algorithm that all implementations support. This document updates RFC 7296 and obsoletes RFC 4307 in defining the current algorithm implementation requirements and usage guidance for IKEv2, and does minor cleaning up of the IKEv2 IANA registry. This document does not update the algorithms used for packet encryption using IPsec Encapsulating Security Payload (ESP).},
}

@misc{rfc8446,
	series =	{Request for Comments},
	number =	8446,
	howpublished =	{RFC 8446},
	publisher =	{RFC Editor},
	doi =		{10.17487/RFC8446},
	url =		{https://rfc-editor.org/rfc/rfc8446.txt},
        author =	{Eric Rescorla},
	title =		{{The Transport Layer Security (TLS) Protocol Version 1.3}},
	pagetotal =	160,
	year =		2018,
	month =		aug,
    langid={english},
	abstract =	{This document specifies version 1.3 of the Transport Layer Security (TLS) protocol. TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery. This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961. This document also specifies new requirements for TLS 1.2 implementations.},
}

@online{par17,
    author = {Arash Partow},
    editor = {Partow.net},
    title = {Primitive Polynomial List},
    url = {www.partow.net/programming/polynomials/index.html},
    lastchecked = {01.03.2020},
    originalyear = {28.05.2017},
    langid = {english}
}

@techreport{mor20,
	number =	{draft-ietf-tls-oldversions-deprecate-06},
	type =		{Internet-Draft},
	institution =	{Internet Engineering Task Force},
	publisher =	{Internet Engineering Task Force},
	note =		{Work in Progress},
	url =		{https://datatracker.ietf.org/doc/html/draft-ietf-tls-oldversions-deprecate-06},
        author =	{Kathleen Moriarty and Stephen Farrell},
	title =		{{Deprecating TLSv1.0 and TLSv1.1}},
	pagetotal =	22,
	year =		2020,
	month =		jan,
	day =		6,
    langid={english},
	abstract =	{This document, if approved, formally deprecates Transport Layer Security (TLS) versions 1.0 (RFC 2246) and 1.1 (RFC 4346) and moves these documents to the historic state. These versions lack support for current and recommended cipher suites, and various government and industry profiles of applications using TLS now mandate avoiding these old TLS versions. TLSv1.2 has been the recommended version for IETF protocols since 2008, providing sufficient time to transition away from older versions. Products having to support older versions increase the attack surface unnecessarily and increase opportunities for misconfigurations. Supporting these older versions also requires additional effort for library and product maintenance. This document also deprecates Datagram TLS (DTLS) version 1.0 (RFC6347), but not DTLS version 1.2, and there is no DTLS version 1.1. This document updates many RFCs that normatively refer to TLSv1.0 or TLSv1.1 as described herein. This document also updates RFC 7525 and hence is part of BCP195.},
}

@unpublished{openssl,
  added-at = {2009-01-31T03:43:30.000+0100},
  author = {{The Open{SSL} Project}},
  biburl = {https://www.bibsonomy.org/bibtex/28796dfa7899f1eeab5e921051d6c3eed/ragibhasan},
  keywords = {openssl},
  month = {April},
  note = {\url{www.openssl.org}},
  timestamp = {2020-03-30},
  title = {{OpenSSL}: The Open Source toolkit for {SSL/TLS}},
  year = 2003,
    langid={english},
}

\end{filecontents}
%% Конец

%% Указываем файл с библиографией.
\addbibresource{reference.bib}

\begin{document}

\studygroup{N3451}
\faculty{ФБИТ}
\specialty{10.03.01 Информационная безопасность}
\specialization{Организация и технология защиты информации}
\title{Разработка модификации алгоритма Диффи-Хеллмана c
    использованием клеточных автоматов}
\author{Крикун Александр Артемович}{Крикун А.А.}
\supervisor{Левина Алла Борисовна}{Левина А.Б.}{к.физ-мат.н.}{доцент, Университет ИТМО}
\publishyear{2020}
%% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
\startdate{12}{декабря}{2019}
%% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
\finishdate{31}{мая}{2020}
%% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
\defencedate{16}{июня}{2019}
\secretary{Коваль Е.Н.}

%% Задание
%%% Техническое задание и исходные данные к работе
\technicalspec{
Цель работы – оптимизация алгоритма Диффи-Хеллмана с помощью распараллеливания алгоритма возведения в степень Монтгомери для применения с ключами большего размера.
Для достижения цели необходимо:
\begin{enumerate}[label=\arabic*.]
    \item Провести анализ алгоритма Диффи-Хеллмана.
    \item Провести анализ известных методов оптимизации шагов алгоритма с помощью клеточных автоматов.
    \item Разработать программную реализацию модификации алгоритма возведения в степень Монтгомери, оптимизированного с помощью параллельных вычислений.
    \item Разработать программную реализацию алгоритма с использованием оптимизированных элементов.
    \item Провести оценку полученных результатов.
\end{enumerate}
}

%%% Содержание выпускной квалификационной работы (перечень подлежащих разработке вопросов)
\plannedcontents{
\begin{enumerate}[label=\arabic*.]
    \item Анализ алгоритма Диффи-Хеллмана и задачи быстрого возведения в степень.
    \item Детальный анализ распараллеливания алгоритма возведения в степень Монтгомери.
    \item Программная реализация оптимизированного алгоритма.
    \item Оценка полученных результатов.
\end{enumerate}
}

\plannedgraphics{
\begin{enumerate}[label=\arabic*.]
    \item Схема алгоритма Диффи-Хеллмана.
    \item Схема алгоритма побитового возведения в степень Монтгомери.
    \item Схема параллелизованного алгоритма побитового возведения в степень Монтгомери.
\end{enumerate}
}

%%% Исходные материалы и пособия
\plannedsources{
\begin{enumerate}[label=\arabic*.]
    \item Paar C. Understanding Cryptography. C. Paar – М.: Springer; 2014. – 392с.
    \item \c{C}.K. Ko\c{c}, T. Acar, Montgomery Multiplication in GF$\left(2^k\right)$,
    Kluwer Academic Publishers, Designs, Codes and Cryptography, 14(1), pp. 57-69, April 1998..
    \item \c{C}.K. Ko\c{c}, T. Acar, Fast software exponentiation in GF$\left(2^k\right)$
    In \emph{Proceedings, 9th Symposium on Computer Arithmetic}, pages 225–231, Asilomar, California, July 6–9, 1997
    \item Menezes A, Oorschot PV, Vanstone S.
    (1997) Handbook of applied cryptography.
    CRC, Boca Raton.
    \item K. Ku, K. Ha, W. Yoo, and K. Yoo, ``Parallel Montgomery multiplication and squaring over GF$\left(2^m\right)$ Based on cellular automata'',
    Proc. ICCSA 2004, (LNCS, 3046), pp. 196-205, 2004
\end{enumerate}
}

%%% Цель исследования
\researchaim{Оптимизация алгоритма Диффи-Хеллмана с использованием параллельного алгоритма
    возведения в степень Монтгомери для применения на пространстве ключей до 8 килобит.}

%%% Задачи, решаемые в ВКР
\researchtargets{\begin{enumerate}
    \item Анализ алгоритма Диффи-Хеллмана.
    \item Анализ известных методов оптимизации шагов алгоритма с помощью клеточных автоматов.
    \item Разработка программной реализации модификации алгоритма возведения в степень Монтгомери, оптимизированного с помощью параллельных вычислений.
    \item Разработка программной реализации алгоритма с использованием оптимизированного возведения в степень.
    \item Тестирование производительности и оценка полученных результатов.
\end{enumerate}}

%%% Использование современных пакетов компьютерных программ и технологий
\addadvancedsoftware{GeoGebra Classic 6.0.581}{\ref{sec:func}}
\addadvancedsoftware{Python 3.7}{\ref{sec:paramont}, \ref{sec:prog}-\ref{sec:results}}
\addadvancedsoftware{Python Image Library 6.1.0}{\ref{sec:paramont}}
\addadvancedsoftware{Matplotlib 3.1.3}{\ref{sec:results}}

%%% Краткая характеристика полученных результатов
\researchsummary{В рамках дипломной работы была реализована открытая библиотека для вычислений в конечных полях, которая
включала как традиционные, так и оптимизированные алгоритмы возведения в степень по модулю.
Были реализованы модификации алгоритма Диффи-Хеллмана, использующие алгоритмы возведения в степень <<слева-направо>>,
Монтгомери и Монтгомери с использованием клеточных автоматов.
Также были проведены сравнительные тесты производительности модификаций.
Предложенная в работе оптимизация позволяет получить прирост производительности в 40\% по сравнению со стандартной версией алгоритма.}


%%% Наличие публикаций и выступлений на конференциях по теме выпускной работы
\researchpublications{
\begin{refsection}
\nocite{kri20}
\printannobibliography
\end{refsection}
}
%% Дата предзащиты
\predefencedate{15}{мая}{2020}
%% Эта команда генерирует титульный лист и аннотацию.
\maketitle{Бакалавр}

%% Оглавление
\tableofcontents

% Введение
\startprefacepage

Для обеспечения конфиденциальности и целостности информации в сети Интернет используется шифрование.
Для шифрования данных пользователям необходимо обеспечить безопасную передачу секретного ключа.
Передача ключа по незащищённому каналу, в открытом виде, компроментирует шифрование, так как
злоумышленник, перехвативший ключ, получает доступ ко всей зашифрованной информацие.
Для решения этой проблемы, в 1976 году, была предложена  криптография с открытым ключом.

Криптография с открытым ключом основана на односторонних функциях (функциях-ловушках),
создающих пару ключей - ключ для шифрования (открытый) и ключ для расшифрования (закрытый).
При этом закрытый ключ для расшифрования  невозможно определить из открыто передаваемого ключа~\cite{dif77}.

Алгоритм обмена ключами Диффи-Хеллмана, предложеный в 1976 году, основан на задаче дискретного логарифмирования
и используется для установления общего секретного ключа между пользователями.
Алгоритм  использует задачу возведения в степень по модулю и её вариации, которые выполняются довольно быстро
(см. главу~\ref{sec:func}) для создания ключа и для шифрования, но атакующему для дешифрования без знания секретной
информации необходимо решить задачу дискретного логарифмирования.
На тех же задачах основан и асимметричный алгоритм Эль-Гамаля.

Подробное объяснение работы алгоритма представлено в главе~\ref{sec:dhke}.
Алгоритм Диффи-Хеллмана широко применяется для защищённого обмена криптографическими ключами
по открытым каналам.
Он является основным алгоритмом обмена ключами в SSH и популярной опцией в TLS и множестве других протоколов.
Алгоритм может быть реализован на модульных группах или эллиптических кривых, но в данной работе рассматривается
реализация на конечных полях, а конкретнее - конечных полях GF($2^k$).
Такие реализации очень хорошо подходят для имплементации на электронных вычислительных машинах (ЭВМ),
так как операции в этих полях переносятся на операции с битами памяти ЭВМ.

Для реализации на конечных полях необходимо выбрать подходящий неприводимый многочлен, его можно считать аналогом модуля (см. главу~\ref{sec:fields}).
Неприводимые многочлены должны отвечать множеству требований.
Например, широко используемые многочлены, предложенные в протоколе Oakley~\cite{rfc2412} являются простыми числами
Софи Жермен, чтобы максимально противостоять атакам по типу алгоритма больших и малых шагов.
Сложность нахождения подходящих многочленов привела к тому, что множество имплементаций следуют устаревшим рекомендациям
IETF (инженерного совета Интернета)~\cite{rfc7296}, в которых приводятся вышеупомянутые группы протокола Oakley.
К сожалению, многие сервера поддерживают устаревшие стандарты для совместимости со старыми системами либо
из-за законов США об экспортной криптографии.
Эти стандарты используют короткие неприводимые многочлены, и существуют методы~\cite{adr15},
позволяющие с помощью предварительных вычислений сократить время решения задачи дискретного логарифмирования для
конкретного многочлена до сравнительно небольшого для современных ЭВМ.
Для повышения криптографической стойкости алгоритма необходимо использовать более длинные многочлены.\par
Работа с более длинными ключами шифрования требует больше вычислений и, соответственно, занимает больше времени.
Но ускорение вычислений позволит увеличить криптографическую стойкость без потери скорости и комфорта пользователей.
Для ускорения возведения в степень по модулю может использоваться несколько алгоритмов, которые будут рассмотрены в
данной работе.

Цель данной работы - рассмотрение, имплементация и сравнение производительности способов оптимизации алгоритма
Диффи-Хеллмана, в частности с использованием алгоритма возведения в степень Монтгомери и его параллелизации
с помощью клеточных автоматов.
Для достижения этой цели были поставлены следующие задачи:
\begin{enumerate}[label=\arabic*.]
    \item Анализ алгоритма Диффи-Хеллмана.
    \item Анализ известных методов оптимизации шагов алгоритма с помощью клеточных автоматов.
    \item Разработка программной реализации модификации алгоритма возведения в степень Монтгомери, оптимизированного
        с помощью клеточных автоматов.
    \item Разработка программной реализации алгоритма с использованием оптимизированных элементов.
    \item Тестирование производительности и оценка полученных результатов.
\end{enumerate}
Успешное решение данных задач приведёт к разработке оптимизированной модификации алгоритма Диффи-Хеллмана,
которую можно будет применять в существующих системах с минимальной модификацией для существенного увеличения длины
криптографического ключа с сохранением скорости работы алгоритма.


\chapter{Теоретические понятия и концепции}

\startrelatedwork
Для подробного объяснения предложенного в работе метода оптимизации необходимо ввести некоторые теоретические понятия.

В данной главе рассмотрены концепции временной сложности алгоритмов, односторонних функций, конечных полей и клеточных автоматов,
также представлены алгоритм Диффи-Хеллмана и алгоритм Монтгомери.

\section{Временная сложность алгоритмов}\label{sec:asympt}

Различные алгоритмы в информатике выполняются за различное время.
Например, возведение числа в степень выполняется быстрее, чем дискретное логарифмирование.
Зависимость времени работы алгоритма от размера входной строки называется временной сложностью алгоритма.
Временная сложность выражается через нотацию <<$\textit{О}$>>-большое~\cite{knu97}.
При вычислении временной сложности алгоритма константы, получаемые при расчетах, не учитываются, и учитывается только слагаемое самого высокого порядка.
Временная сложность обычно оценивается с помощью подсчёта числа элементарных операций, исполняемых алгоритмом.
Время исполнения одной операции считается за константу.
Так как время работы зависит не только от размера входной строки, но и от её характеристик,
в большинстве случаев берётся время работы для худшего варианта.

Временная сложность алгоритма классифицируется в зависимости от его $\textit{О}$-нотации.
Рассмотрим нескольно классов временной сложности:

\textbf{Константное время $O(1)$:}
Алгоритм исполняется за постоянное время,
если время исполнения не зависит от размера входных данных.
Примером такого алгоритма будет обращение к памяти или получение элемента из массива.
Так как в нотации <<$\textit{О}$>>-большое отбрасываются константы, время считается за $O(1)$.

\textbf{Логарифмическое время $O(log~n)$:}
Алгоритмы, работающие за логарифмическое время, считаются высокоэффективными, поскольку
отношение размера массива входных данных ко времени работы алгоритма уменьшается с ростом размера массива.
Пример такого алгоритма - бинарный поиск элемента в отсортированном массиве.

\textbf{Линейное время $O(n)$:}
Алгоритм исполняется за линейное время, если при достаточно большом размере массива входных данных
время его исполнения растёт линейно от размера входа.
Выполнение за линейное время является желательным атрибутом алгоритма.
Примером такого алгоритма является нахождение суммы элементов массива.

\textbf{Полиномиальное время $O(n^k)$:}
Алгоритм исполняется за полиномиальное время, если количество операций можно оценить как $O(n^k)$ для некоторой константы $k$.
Тезис Кобэма-Эдмондса утверждает, что решение некоторой задачи возможно вычислить на каком-либо устройстве только в случае,
если алгоритм для её решения может быть исполнен за полиномиальное время.
Таким образом, <<исполняется за полиномиальное время>> может считаться синонимом понятий <<быстрый>>, <<простой>>, <<эффективный>>
или <<выполнимый>>.

Задачи, для которых существуют алгоритмы с детерминированным полиномиальным временем, составляют класс сложности $P$.
Этот класс является центральным в теории вычислительной сложности.
Примером алгоритма, исполняемого за полиномиальное время, можно считать быструю сортировку массива.
Также за полиномиальное время выполняются операции умножения и возведения в степень - за $n$ в данном случае
берётся длина числа.

\textbf{Экспоненциальное время $O(2^{n^k})$:}
Алгоритм исполняется за экспоненциальное время, если количество операций можно оценить как $O(2^{n^k})$ для некоторой константы $k$.
Считается, что алгоритмы с полиномиальной сложностью <<быстрые>>, а алгоритмы со сложностью больше полиномиальной - <<медленные>>.
Хотя для малых значений $n$ полиномиальное время работы может превосходить экспоненциальное, на больших
значений $n$ время работы алгоритма с экспоненциальной сложностью существенно больше и растёт гораздо
быстрее.

Существуют также алгоритмы, которые работают более, чем за полиномиальное время, но менее, чем за экспоненциальное.
Их называют сверх-полиномиальными или суб-экспоненциальными.
Такие алгоритмы также считаются <<медленными>>.
Примеры <<медленных>> алгоритмов - разложение числа на простые сомножители, алгоритм решения задачи
дискретного логарифмирования.

\section{Односторонние функции}\label{sec:func}

Криптография с открытым ключом (асимметричное шифрование) основана на математических преобразованиях, которые сложно обратить.
Такие преобразования называются односторонними функциями, или функциями-ловушками.

Односторонними можно считать функции, которые обладают следующими свойствами:
\begin{description}
  \item[$\bullet$] Для любого известного $x$ функция $f(x)$ вычислима за полиномиальное время.
  \item[$\bullet$] Для любого известного $y=f(x)$ нет способа вычислить $x$ за полиномиальное время.
\end{description}
Нахождение новой односторонней функции - сложная задача, но существует некоторый набор известных функций,
которые широко используются в криптографии~\cite{sma15, men01}.\par
Самая известная односторонняя функция лежит в основе первого алгоритма асимметричного шифрования RSA\@.
Для шифрования используется операция возведения в степень по модулю большого числа.
Для выполнения обратной операции - дешифрования - необходимо вычислить функцию Эйлера
от данного большого числа, для чего необходимо выполнить разложение его на простые множители, или решить задачу факторизации.
Задача факторизации решается за суб-экспоненциальное время, и, как упомянуто в главе~\ref{sec:asympt}, является <<медленной>>.

Алгоритм Диффи-Хеллмана предназначен для обмена ключами.
В алгоритме также используется операция возведения в степень по модулю большого числа, но делается это несколько иначе.
Для формирования секретного ключа используются открытые база $g$ и модуль $n$, а также секретные числа $a$ и $b$.
База $g$ возводится в степень $a$ и $b$, а затем $g^a\pmod{n}$ и $g^b\pmod{n}$ передаются по незащищённому каналу связи.
Таким образом, для получения общего ключа необходимо одному пользователю $g^a$ возвести в степень $b$,
а второму $g^b$ возвести в степень $a$.
Оба пользователя получают одинаковый секретный ключ $g^{ab}\pmod{n}$.
Атакующему для нахождения секретного ключа необходимо решить задачу дискретного логарифмирования в конечном поле,
а именно при данных $g$ и $g^a\pmod{n}$ найти $a$.

Вычислительная сложность этой задачи зависит от группы, в которой выполняются вычисления.
Для некоторых групп такая задача будет тривиальной.
Поэтому в основном используются группы, тщательно подобранные экспертами~\cite{rfc2412}.
Подробнее тема конечных полей будет раскрыта в главе~\ref{sec:fields}.
В правильно подобранном поле вычислительная сложность растёт в лучшем случае суб-экспоненциально.
Быстрое возведение в степень же для при числе и модуле размерности $n$ бит и степени размерности $k$ бит
выполняется за $О(M(n)k)$, где $M(n)$ - это временная сложность выбранного алгоритма умножения, то есть <<быстро>>.

\begin{figure}[!b]
\caption{Иллюстрация операции суммы на эллиптических кривых}\label{fig:ec_sum}
\includegraphics[width=15cm]{graphics/ec_summation.png}
\end{figure}
\begin{figure}[!h]
\caption{Иллюстрация операции удвоения на эллиптических кривых}\label{fig:ec_doub}
\includegraphics[width=15cm]{graphics/ec_doubling.png}
\end{figure}
Также в современной криптографии как односторонняя функция широко используется умножение на эллиптических кривых.
Эллиптическая кривая - это набор точек в конечном поле, подходящих под уравнение $y^2=x^3+ax+b$.
Умножение определено как повторяющееся $n$ раз сложение точки $P=(x,y)$, лежащей на этой кривой: $nP=P+P+\dots+P$
Сложение на эллиптической кривой можно описать как проведение линии через две точки, а затем отражение точки пересечения этой линии с кривой.
Если посмотреть на рисунок~\ref{fig:ec_sum}, то $A+B=-E=F$.
Для ускорения умножения можно использовать операцию удвоения, которую можно описать как проведение касательной к точке и
отражение точки пересечения касательной и кривой.
Если посмотреть на рисунок~\ref{fig:ec_doub}, то $C+C=-B=G$.
За счёт удвоения можно сократить количество операций с $n$ умножений до $log_2 n$ удвоений и небольшого числа умножений.
Это аналогично методу оптимизации <<возводи в квадрат и умножай>> для возведения числа в степень, который будет раскрыт в главе~\ref{sec:oper}.
На эллиптических кривых задача, обратная к умножению, также называется задачей дискретного логарифмирования.
Но на эллиптических кривых она решается за экспоненциальное время, то есть она сложнее, чем аналогичная задача на конечных полях.
За счёт этого в криптографии на эллиптических кривых используются ключи гораздо меньшего размера для достижения той же вычислительной сложности.\par
Несмотря на это, из-за сложностей реализации криптографии на эллиптических кривых чаще используется криптография в конечных полях.
Поэтому в данной работе рассматривается оптимизация алгоритма Диффи-Хэлмана именно для конечных полей $GF(2^k)$, которые подробно рассмотрены в главе~\ref{sec:fields}.

\section{Алгоритм Диффи-Хеллмана}\label{sec:dhke}

В 1976 году Уитфилдом Диффи и Мартином Хеллманом была опубликована статья <<New Directions in Cryptography>>
(<<Новые направления в криптографии>>)~\cite{dif77}, в которой были изложены основы криптографии с открытым ключом.
В отличие от симметричной криптографии, в которой ключ шифрования один и всегда держится в секрете,
в асимметричной криптографии у каждого пользователя существует два различных ключа - открытый (публичный) и закрытый (секретный).
Сообщение, зашифрованное открытым ключом, может быть расшифровано только соответствующим ему закрытым ключом, и наоборот.
Асимметричная криптография используется для широкого круга задач - от непосредственно шифрования до цифровых подписей.
Однако для шифрования коммуникаций целиком оно используется редко, так как асимметричное шифрование гораздо
медленнее симметричного.
Гораздо чаще с помощью асимметричного алгоритма устанавливается ключ, который используется для симметричного шифрования
последующих коммуникаций.
Именно для этой цели и предназначен алгоритм Диффи-Хеллмана.\par
Алгоритм Диффи-Хеллмана позволяет двум абонентам установить ключ для шифрования последующих коммуникаций,
используя только коммуникации по открытому каналу.
Это выгодно отличает его от предыдущих способов установления ключа шифрования, которые требовали передачи
физического ключа курьером или заказным письмом.
Алгоритм Диффи-Хеллмана основывается на задаче дискретного логарифмирования, и при правильном подборе условий,
взлом его требует решения задачи с суб-экспоненциальной или экспоненциальной временной сложностью.\par
Для непосредственного установления ключа два абонента \textbf{А} и \textbf{Б} должны выбрать базу $g$ и модуль $n$, которые
могут передаваться в открытом виде, и секретные ключи $a$ и $b$, которые генерируются случайно.
Каждый абонент независимо вычисляет открытые ключи:
\begin{gather*}
    A = g^a\pmod{n}\\
    B = g^b\pmod{n}\\
\end{gather*}
И пересылает их другому абоненту по незащищённому каналу связи.
Затем абоненты независимо вычисляют общий секретный ключ:
\begin{gather*}
    S = A^b\pmod{n}\\
    S = B^a\pmod{n}\\
\end{gather*}
Который получается у них одинаковым из-за коммутативности показателей при последовательном возведении в степень:
\[(g^a)^b \pmod{n} \equiv (g^b)^a \pmod{n} \equiv g^{a*b}\pmod{n}\]
Полученный ключ $S$ можно использовать для последующего шифрования.
Если все коммуникации абонентов перехватят, то для получения ключа шифрования необходимо будет решить
вычислительную задачу Диффи-Хеллмана: найти $g^{ab}\pmod{n}$ по известным $g$, $n$, $g^a$ и $g^b$.
Решение задачи Диффи-Хеллмана можно свести к решению задачи дискретного логарифмирования~\cite{sma15},
для которой пока не известно решений за полиномиальное время.

У алгоритма Диффи-Хеллмана есть ещё одно важное преимущество, так как пары открытый-закрытый ключ ($a, g^a$) у каждого абонента независимы, любой абонент может инициировать
обновление общего секретного ключа.
С ростом объёма зашифрованных симметричным шифром данных повышается вероятность успешного подбора ключа с помощью
частотного криптоанализа.
Алгоритм Диффи-Хеллмана позволяет избежать этого установлением определённого периода времени или объёма данных
между обновлениями ключа симметричного шифрования.
Если использовать эту меру, даже после утечки ключа симметричного шифрования нарушитель получит доступ только к части
данных, но не ко всей переписке.

Для надёжности алгоритма необходимо правильно подбирать публичные переменные $g$ и $n$.
$n$ должно быть простым, но не все простые числа подходят для этого значения.
Например, если $n-1$ раскладывается на небольшие простые множители, задача дискретного логарифмирования
может быть решена за полиномиальное время с помощью алгоритма Полига-Хеллмана~\cite{men01}.
Поэтому большинство имплементаций следуют рекомендациям IETF (инженерного совета Интернета)~\cite{rfc7296}, в которых
приводятся рекомендуемые значения переменных $g$ и $n$.

Повсеместное следование устаревшим рекомендациям IETF в сочетании с требованиями правительства США к экспортной криптографии
привело к тому, что некоторые сервера можно заставить использовать устаревшие стандарты криптографии, в которых
используется небольшой размер ключа менее 512 бит~\cite{adr15}.
Существуют алгоритмы, позволяющие с помощью предварительных вычислений сократить время решения задачи
дискретного логарифмирования для известного из рекомендаций значения $n$ длиной 512 бит до примерно 70 секунд, что сводит
безопасность шифрования к нулю.
В той же статье было высказано предположение, что ключи в 768 бит также небезопасны, а ключи длиной
в 1024 бит могут быть скомпроментированы с ресурсами правительства и не должны считаться достаточными для шифрования.
Таким образом, для достижения безопасности коммуникаций рекомендуется использовать ключи длиной от 2048 бит,
для которых задача дискретного логарифмирования в $10^9$ раз сложнее, чем для 1024 бит.

Но с использованием более длинных ключей растёт и время работы алгоритма.
Основные вычисления в алгоритме Диффи-Хеллмана - это возведения в степень по модулю, используемые для вычисления секретных ключей,
которые выполняются за полиномиальное время.
Но алгоритм можно оптимизировать и внутри этого класса временной сложности.
С помощью оптимизации алгоритма, которая рассматривается в данной работе, можно достичь удлинения ключей шифрования
практически в полтора раза по сравнению со стандартной реализацией без потерь в скорости работы.
То есть реализации, которые использовали ключи в 1024 бита, смогут перейти на ключи в 1536 бит без потерь в скорости работы,
но с экспоненциальным приростом временной сложности задачи дискретного логарифмирования, и, следовательно, безопасности
шифрования.

\section{Конечные поля}\label{sec:fields}

Современная криптография с открытым ключом основана на арифметике остатков~\cite{sma15, men01, knu97_2}.
В арифметике остатков для любых вычислений фиксируется положительное натуральное число $N$, которое называется модулем.
Если разность двух чисел $b-a$ делится нацело на $N$, то $a$ и $b$ сравнимы по модулю $N$:
\[a \equiv b \pmod{N}\]
В этом случае $a$ и $b$ имеют одинаковый остаток от деления на $N$.
Все возможные остатки от деления чисел на $N$ образуют множество значений оператора модуля $\pmod{N}$:
\[\mathbb{Z}/N\mathbb{Z}=\{0,\dots,N-1\}\]
Поскольку все сравнимые по между собой по модулю $N$ числа имеют один и тот же остаток, можно считать, что
элемент $x\in\mathbb{Z}/N\mathbb{Z}$ - это представление класса чисел вида $x+kN, k\in\mathbb{Z}$.
Таким образом, при операциях по модулю $N$ можно считать сравнимые между собой числа равными друг другу:
\[a+kN\pmod{N} = a, k \in \mathbb{Z}\]


На множестве $\mathbb{Z}/N\mathbb{Z}$ определены две основных операции -- сложение и умножение.
Они определяются через аналогичные операции на множестве целых чисел.
Они обладают следующими свойствами:
\begin{enumerate}[label=\arabic*.]
    \item Замкнутость сложения и умножения:
    \[\forall a, b \in \mathbb{Z}/N\mathbb{Z}: a+b\in \mathbb{Z}/N\mathbb{Z}, a*b\in \mathbb{Z}/N\mathbb{Z}\]
    \item Ассоциативность сложения и умножения:
    \[\forall a, b, c \in \mathbb{Z}/N\mathbb{Z}: (a+b)+c = a+(b+c), (a*b)*c = a*(b*c)\]
    \item Существование единичного элемента по сложению и умножению:
    \[\forall a \in \mathbb{Z}/N\mathbb{Z}: a+0 = 0+a = a, a*1 = 1*a = a\]
    \item Существование обратного элемента по сложению:
    \[\forall a \in \mathbb{Z}/N\mathbb{Z}: a+(N-a) = (N-a)+a = 0\]
    \item Коммутативность сложения и умножения:
    \[\forall a, b \in \mathbb{Z}/N\mathbb{Z}: a+b = b+a, a*b = b*a\]
    \item Сложение и умножение связаны законом дистрибутивности:
    \[\forall a, b, c \in \mathbb{Z}/N\mathbb{Z}: (a+b)*c = a*c + b*c\]
\end{enumerate}
Множество, на котором определена операция, удовлетворяющая свойствам $1-4$, называется группой.
Если эта операция удовлетворяет и свойству $5$, она называется коммутативной.
Группы классифицируются по типу групповой операции - аддитивные $(G, +)$ и мультипликативные $(G,*)$.
Группа, в которой существует элемент, многократным применением к которому групповой операции можно получить
любой другой элемент этой группы, называется циклической, а такой элемент -- образующей.
Например, в группе целых чисел по сложению образующей будет $1$.

Образующая $g$ для циклической группы $G$ обозначается $G=\langle g \rangle$.
В мультипликативном случае каждый элемент $h$ группы $G$ можно записать как:
\[\forall h \in G: h=g^x\]
А в аддитивном случае:
\[\forall h \in G: h=g*x\]
$x$ в обоих случаях -- некоторое целое число, называемое дискретным логарифмом $h$ по основанию $g$.

Множество $R$, на котором определены две операции -- сложение и умножение, которые обладают свойствами
$1-5$, кроме коммутативности умножения, называется кольцом $(R,*,+)$.
Если операция умножения в данном кольце коммутативна, оно называется коммутативным кольцом.
Приведённое выше множество остатков $\mathbb{Z}/N\mathbb{Z}$ с операциями сложения и умножения
является коммутативным кольцом и называется кольцом вычетов по модулю $N$.

Одна из главных задач арифметики остатков -- это поиск элемента $x\in\mathbb{Z}/N\mathbb{Z}$, который удовлетворяет равенству:
\[a*x=b\pmod{N}\]
С вещественными коэффициентами при $a \neq 0$ линейное уравнение $a*x=b$ всегда разрешимо.
При рассмотрении над кольцом целых чисел не всегда существует ответ, а для кольца вычетов есть три случая,
которые разделяются в зависимости от наибольшего общего делителя (НОД) чисел $a$ и $N$.
\begin{enumerate}[label=\arabic*.]
    \item Уравнение может иметь ровно одно решение при НОД$(a,N) = 1$:
    \[2*x=3\pmod{91}\]
    \item Может иметь $g = $ НОД$(a,N)$ решений при $g \neq 1$ и $b$, делимом на $g$:
    \[3*x=6\pmod{91}\]
    \item В других случаях уравнение решений не имеет:
    \[7*x=3\pmod{91}\]
\end{enumerate}

При НОД$(a,N) = 1$ числа $a$ и $N$ называются взаимно простыми.
Число элементов кольца $\mathbb{Z}/N\mathbb{Z}$, взаимно простых с $N$, можно найти с помощью функции Эйлера $\varphi$.
$\varphi(N)$ можно найти с помощью разложения $N$ на простые множители.
Если $p_i$ - различные простые числа:
\begin{gather*}
    N = \prod_{i=1}^n p_i^{e^i}\\
    \varphi(N) = \prod_{i=1}^n p_i^{e^i-1}(p_i-1)\\
\end{gather*}
Следовательно, для простого $p$:
\[\varphi(p) = p-1\]
И для простых $p$ и $q$, $p \neq q$:
\[\varphi(p*q) = (p-1)*(q-1)\]
Для взаимно простых $a$ и $N$ существует единственное $c$, удовлетворяющее следующему равенству:
\[a*c \equiv c*a \equiv 1 \rmod{N}\]
Такое $c$ называется мультипликативным обратным к $a$ и обозначается как $a^{-1} \pmod{N}$.
При простом модуле $N=p$ для любого ненулевого элемента $N$ существует единственно мультипликативно обратное.
\[ \forall a \in (\mathbb{Z}/p\mathbb{Z}) \backslash \{0\} ~ \exists! a^{-1}: a*a^{-1} = 1 \pmod{p}\]

Коммутативное кольцо $(F,*,+)$, которое также обладает следующими свойствами:
\begin{enumerate}[label=\arabic*.]
    \item $(F,+)$ -- коммутативная группа с единичным элементом 0,
    \item $(F \backslash \{0\},*)$ -- коммутативная группа с единичным элементом 1,
    \item $0\neq1$ -- единичные элементы по сложению и умножению неравны,
    \item $(F,*,+)$ -- операции сложения и умножения удовлетворяют закону дистрибутивности.
\end{enumerate}
Называется конечным полем.
Конечное поле - это коммутативное кольцо, в котором каждый элемент обратим.
Если $(\mathbb{Z}/N\mathbb{Z})^*$ -- множество обратимых элементов в $\mathbb{Z}/N\mathbb{Z}$:
\[(\mathbb{Z}/N\mathbb{Z})* = \{x \in \mathbb{Z}/N\mathbb{Z} | ~ \text{НОД}(x, N) = 1\}\]
Количество элементов этого множества будет равно значению функции Эйлера:
$|(\mathbb{Z}/N\mathbb{Z})^*| = \varphi (N)$.

При простом $N=p$ каждый элемент кольца $\mathbb{Z}/p\mathbb{Z}$ взаимно прост с $p$ и поэтому обратим,
из чего следуют два свойства:
\begin{gather*}
    (\mathbb{Z}/p\mathbb{Z})^* = \{1, \dots, p-1\}\\
    F \backslash \{0\} = F^*\\
\end{gather*}
Целые числа по модулю $N$ образуют поле тогда и только тогда, когда $N$ -- простое число.

Конечные поля существуют не только на целых числах.
В криптографии используется более общий тип конечных полей, на которых могут быть переопределены операции сложения и умножения.
Основанием такого поля является простое число $p$ в степени $k$.
В данной работе рассматриваются поля $GF (2^k)$, содержащие $2^k$ элементов.
Переменные в таких полях можно представлять как многочлены от степеней основания поля:
\[a(x) \in GF(2^k) = \sum_{i=0}^{k-1}a_i x^i = a_{k-1}x^{k-1} + a_{k-2}x^{k-2} + \dots + a_1 x + a_0\]
Уравнение для целых чисел по модулю $N$:
\[a*x = b \pmod{N}\]
Для конечных полей $GF(2^k)$ переопределяется как:
\[a(x) \cdot \alpha = b(x) \pmod{f(x)}]\]
Как и в случае для целых чисел, ответ зависит от НОД$(a(x), f(x))$.
Многочлен называется неприводимым, если у него нет делителей, отличных от него самого и единичного элемента.
Таким образом, неприводимые многочлены являются аналогами простых чисел в конечных полях.
Конечное поле всегда определено относительно неприводимого многочлена.

% Здесь можно расписать про изоморфизм. Нужно ли?
Для любых двух конечных полей с одинаковым основанием (степенью простого числа), определённых относительно различных
неприводимых многочленов можно построить однозначное отображение всех элементов одного поля в другое.
То есть для любого основания существует единственное (с точностью до изоморфизма) конечное поле с числом
элементов, равным степени простого числа.
Ненулевые элементы конечного поля $GF(2^k)^*$ составляют конечную коммутативную циклическую группу.
Образующая группы $GF(2^k)^*$ называется примитивным элементом конечного поля.
Примитивный элемент существует в любом конечном поле, и любой ненулевой элемент поля может быть выражен через его степень:
\[\forall \alpha \in GF(2^k)^* ~ \exists x \in \mathbb{Z}: \alpha = g^x\]

Теперь можно разъяснить, что для реализации алгоритма Диффи-Хеллмана на конечных полях открытые параметры алгоритма
$g$ и $n$ -- переопределяются соответственно как примитивный элемент и неприводимый многочлен, определяющие конечное поле.
Переменные же $a$ и $b$ -- элементы этого конечного поля.
Переопределение операций умножения и возведения в степень раскрыто в главе~\ref{sec:oper}.

Конечные поля $GF(2^k)$ широко применяются в криптографии.
Основная причина для широкого использования - это простота в имплементации и скорость работы.
Эти показатели достигаются за счёт структуры памяти ЭВМ.
В бинарной структуре (true/false) ячеек памяти ЭВМ можно без каких-либо модификаций хранить элементы
таких полей, а также возможны различные оптимизации операций сложения и умножения.
Эти преимущества распространяются и на программные, и на аппаратные реализации~\cite{koc98}.
Для сравнения, имплементации полей на $GF(p^k)$ для $p > 2$ сложнее, и аналогичные операции в таких полях выполняются
примерно в два раза медленнее~\cite{mau15}.


\section{Некоторые операции в конечных полях}\label{sec:oper}

В конечных полях $GF(2^k)$ операции сложения и вычитания переопределены как сложение по модулю $2$.
Эта операция похожа на сложение в двоичной системе, но переполнения модуля отбрасываются, то есть нет переносов.
То есть в конечном поле $GF(2^k)$ $1+1 = 1-1 = 0$.
На ЭВМ эта операция реализуется через побитовое исключающее ИЛИ и выполняется эффективно - специальной инструкцией процессора.

Умножение производится относительно неприводимого многочлена $n(x)$:
\[c(x) = a(x) \cdot b(x)\pmod{n(x)}\]
и все переносы также отбрасываются.
Умножение и деление на два  на ЭВМ производятся через побитовые сдвиги:
\[a(x) \cdot x = \sum_{i=0}^{k-1}a_i x^i = a_{k-2}x^{k} + a_{k-2}x^{k-1} + \dots + a_1 x^2 + a_0 x\]
После умножения на 2 для взятия модуля может быть вычтен неприводимый многочлен.

В реализации для данной работы для умножения использовался модифицированный для конечных полей GF$(2^k)$метод
<<древнеегипетского>> или <<крестьянского>> умножения.
Для данных $a(x)$ и $b(x)$ алгоритм получает $c(x) = a(x) \cdot b(x) \pmod{n(x)}$:
\begin{lstlisting}[mathescape=true]
    $\textit{Вход}: ~a(x), ~b(x), ~n(x)$
    $\textit{Выход}:~c(x) = a(x) \cdot b(x)\pmod{n(x)}$
    1: $c(x)=0$
    2: for $i=0$ to $k-1$:
    3:      $c(x) = c(x) + b_0 a(x)$
    4:      $b(x) = b(x)/x$
    5:      $car = a_{k-1}$
    6:      $a(x) = a(x) \cdot x$
    7:      if $car == 1$: $a(x) = a(x) - n(x)$
\end{lstlisting}
Если на каком-то шаге значение $a(x)$ становится больше неприводимого многочлена (что выявляется на шаге 5), на шаге 7
от него берётся остаток по модулю.
Отметим, что это происходит через эффективную операцию побитового исключающего ИЛИ.
Сумма двух элементов $GF(2^k)$ никогда не будет больше неприводимого многочлена, так как переносы при сумме отбрасываются.
Следовательно, на четвёртом шаге алгоритма операция взятия остатка по модулю не нужна.

Для вычисления НОД и мультипликативно обратных использовалась вариация расширенного алгоритма Евклида
- алгоритм Бланкиншипа.
В расширенном алгоритме Евклида решается уравнение $a(x) \cdot u + n(x) \cdot v =$ НОД$(a(x), ~b(x))$.
$u$ и $v$ - это коэффициенты Безу для чисел $a(x)$ и $b(x)$.
При $b(x)$, равном неприводимому многочлену $u$ будет мультипликативно обратным к $a(x)$, а НОД$(a(x), ~b(x)) = 1$.
В алгоритме Бланкиншипа определяется матрица:
\begin{equation*}
M =
\begin{pmatrix}
a(x) & 1 & 0 \\
b(x) & 0 & 1\\
\end{pmatrix}
\end{equation*}
Затем к первому столбцу применяется алгоритм Евклида:
\begin{lstlisting}[mathescape=true]
    $\textit{Вход}: ~a(x), ~b(x)$
    $\textit{Выход}:~a(x) + b(x) = \textit{НОД}(a(x), ~b(x))$
    1: while $a > 0$ and $b > 0$:
    2:      if $a > b$:
    3:          $a = a \% b$
    4:       else:
    5:          $b = b \% a$
\end{lstlisting}
Те же операции распространяются на остальные столбцы.
Алгоритм заканчивается, когда в первом столбце появляется НОД$(a(x), b(x))$.
Во второй строке остаются НОД$(a(x), ~b(x)), ~u, ~v$.

Для возведения в степень в конечных полях используются различные алгоритмы бинарного возведения в степень.
В данной работе используется самый распространённый алгоритм возведения в степень слева направо (left-to-right binary exponentiation)~\cite{koc97}.
Для данных $m(x)$ и $e$ алгоритм позволяет вычислить $c(x) = m(x)^e \pmod{n(x)}$ несоизмеримо быстрее метода последовательных умножений:
\begin{lstlisting}[mathescape=true]
    $\textit{Вход}: ~m(x), ~e, ~n(x)$
    $\textit{Выход}:~c(x) = m(x)^e \pmod{n(x)}$
    1: $c(x) = 1$
    2: for $i=k-1$ downto $0$:
    3:      $c(x) = c(x) \cdot c(x)$
    4:      if $e_i$ == 1: $c(x) = m(x) \cdot c(x)$
\end{lstlisting}
Умножения в алгоритме выполняются по вышеуказанному модифицированному <<крестьянскому>> алгоритму и учитывают остатки от деления.

Имплементация данных операций позволила получить эффективную реализацию алгебры в конечных полях $GF(2^k)$.
Такая реализация считается базовой и описывается во многих учебниках по криптографии и программированию~\cite{men01,sma15,knu97_2}.
Она служила опорной точкой для сравнения с оптимизированными вариантами, которые описаны далее.


\section{Алгоритм Монтгомери}\label{sec:mont}

Арифметика Монтгомери~\cite{men01,sma15} позволяет создавать эффективные реализации алгоритмов умножения по модулю без непосредственного выполнения операции деления по модуля.
Арифметика Монтгомери работает с альтернативным представлением чисел, которое называется представлением Монтгомери.
Представим, что $n$ - это положительное целое число длиной $k$ бит, и зададим $r$ и $a$ как
$r = 2^k, \text{НОД}(n,r) = 1$ и $0 \leq a < nR$~\cite{koc98}.
Тогда перевод $a$ в форму Монтгомери производится с помощью следующей формулы:
\[\overline{a} = a \cdot r \pmod{n}\]
Преимущество представления Монтгомери - это перенос математических операций из модуля $n$ под модуль $r$.
Так как $r$ - это степень двойки, такой перенос качественно ускорит выполнение этих операций.
Деления будут выполняться с помощью побитовых сдвигов, а операцию взятия модуля можно заменить побитовой маской.

Побитовые алгоритмы умножения Монтгомери используют только две операции - сдвиг на один бит вправо и побитовое исключающее ИЛИ.
Обе команды выполняются через один процессорный вызов вместо нескольких последовательных и поэтому дают выигрыш в скорости.
Для умножения Монтгомери (в дальнейшем в формулах как МММ) используется следующий алгоритм~\cite{koc98}:
\begin{lstlisting}[mathescape=true]
    $\textit{Вход}: ~\overline{a}(x), ~\overline{b}(x), ~n(x)$
    $\textit{Выход}:~\overline{c}=c \cdot r \pmod{n(x)}$
    1: $\overline{c}(x)=0$
    2: for i=0 to k-1
    3:      $\overline{c}(x)=\overline{c}(x)+a_i b(x)$
    4:      $\overline{c}(x)=\overline{c}(x)+\overline{c}_0 n(x)$
    5:      $\overline{c}(x)=\overline{c}(x)/x$
\end{lstlisting}
Такое умножение проводится с числами в форме Монтгомери:
\[\overline{c} \equiv \overline{a} \cdot \overline{b} \cdot r^{-1} \pmod{n(x)}
\equiv a \cdot r \cdot b \cdot r \cdot r^{-1} \pmod{n(x)}
\equiv c \cdot r \pmod{n(x)}\]
Из этой эквивалентности следует, что для перевода в форму Монтгомери также можно использовать умножение Монтгомери на $r(x)^2$,
а для перевода обратно - на единицу.
Такой метод и применялся в имплементации.

Необходимость перевода чисел в представление Монтгомери и обратно даёт некоторые дополнительные затраты времени, за счёт которых одно умножение Монтгомери выполняется медленнее обычного.
Но случаях выполнения множества последовательных умножений представление Монтгомери даёт значительный прирост в скорости операций.
Важный для данной работы случай последовательных умножений - это возведение в степень.
В форме Монтгомери оно производится по следующему алгоритму~\cite{koc97}:
\begin{lstlisting}[mathescape=true]
    $\textit{Вход}: ~m(x), ~e, ~n(x), ~r^2 = r(x) \cdot r(x) \pmod{n(x)}$
    $\textit{Выход}:~c(x) = m(x)^e \pmod{n(x)}$
    1: $\overline{m}(x) = \text{MMM}(m(x), r^2)$
    2: $\overline{c}(x) = \text{MMM}(1, r^2)$
    3: for i=0 to k-1
    4:      if $e_i$ == 1: $\overline{c}(x) = \text{MMM}( \overline{m}(x), \overline{c}(x))$
    5:      $\overline{m}(x) = \text{MMM}( \overline{m}(x), \overline{m}(x))$
    6: $c(x) = \text{MMM}( \overline{c}(x), 1)$
\end{lstlisting}

Алгоритм возведения в степень Монтгомери даёт значительный выигрыш в скорости по сравнению со стандартным алгоритмом
<<слева направо>>, описанным в главе~\ref{sec:oper}.
Он также использовался при тестировании производительности, проведённом для работы.
Похожий алгоритм используется в OpenSSL~\cite{openssl}, самой популярной библиотеке для криптографии.

Возможны и аппаратные реализации алгоритма Монтгомери.
Шаги алгоритма в них реализуют с помощью элементарных логических элементов.
Для описания аппаратных реализаций часто используется концепция клеточных автоматов~\cite{jeo07, ku04}.

\section{Клеточные автоматы}\label{sec:cells}

Клеточные автоматы были созданы в 1940-е годы Джоном фон Нейманом.
Классический клеточный автомат - это упорядоченный набор ячеек памяти, образующий n-мерную решётку.
Наибольшее распространение получили одно- и двухмерные автоматы.

Каждая ячейка может хранить одно значение из конечного набора, часто - один бит.
Время для клеточных автоматов измеряется дискретными значениями - тактами.
Смена значений происходит одновременно и независимо во всех ячейках со сменой такта в соответствие с правилом перехода:
новое значение каждой ячейки вычисляется как функция от значений соседних ячеек.
Также имеет значение радиус окрестности - количество соседних клеток, определяющих правило перехода.
Вот пример правила перехода для одномерного клеточного автомата с радиусом 1:
\begin{table}[h]
\begin{tabular}{ l l l l l l l l l }
Состояние ячейки и соседей: & 111 & 110 & 101 & 100 & 011 & 010 & 001 & 000 \\
Следующее состояние: & ~0 & ~1 & ~0 & ~0 & ~1 & ~0 & ~0 & ~1 \\
\end{tabular}
\end{table}

Имеет значение и тип ограничений на крайних ячейках клеточного автомата.
Существуют автоматы, в которых считается, что ячейки на границах всегда имеют значение 0.
Такой подход плохо генерализуется на автоматы с большим радиусом.
Более общий подход - считать нулевыми ячейки <<за границами>> конфигурации.
Но наиболее популярный тип, используемый и в данной работе - это <<склейка>>, при котором крайние клетки считаются соседними.
Таким образом, строка для одномерного автомата превращается в кольцо.

\begin{figure}[!h]
\caption{Иллюстрация работы клеточного автомата Вольфрама 73}\label{fig:wolf73}
\includegraphics[width=15cm]{graphics/rule73_r10.png}
\end{figure}

Для одномерных клеточных автоматов с радиусом окрестности 1, как правило, применяется классификация Стивена Вольфрама~\cite{wol02}.
Такие автоматы называются элементарными.
Так как для радиуса 1 существует 8 различных комбинаций состояний ячеек, всего существует $2^8=256$ правил перехода.
Вольфрам предложил нумеровать их по двоичному числу, которое формируют состояния.
Так, для примера выше обозначаение Вольфрама - 1001001, или 73.
На рисунке~\ref{fig:wolf73} изображено 50 тактов работы такого клеточного автомата.
Белые клетки соответствуют состоянию <<0>>, чёрные - <<1>>.
Первая строка случайно заполнена с вероятностью 10\%, затем пропущено 100 тактов для устранения изначальной.
Иллюстрация была создана с помощью разработанной для работы библиотеки, позволяющей генерировать как статические, так и динамические изображения
на основе клеточных автоматов различных классов и радиусов окрестности.

Вольфрам выделил четыре класса элементарных клеточных автоматов.
Правило 73 хорошо иллюстрирует эти классы.
\begin{itemize}
    \item Автоматы первого класса быстро вырождаются либо приходят в однородное состояние.
        Для правила 73 образцом будут стабильные <<колонны>>, которые не пропускают информацию и не изменяются.
    \item Автоматы второго класса приходят к циклическому или стабильному состоянию.
        К такому классу относятся, например, конфигурации из точек, образовавшиеся между некоторыми <<колоннами>>.
    \item Автоматы третьего класса сохраняют случайное состояние.
        Например, широкие столбцы на рисунке~\ref{fig:wolf73} не образуют стабильного цикла даже за 10000 тактов.
    \item Наконец, автоматы четвёртого класса образуют области со стабильными состояниями, но сохраняют и области со сложными взаимодействиями.
        Правило 73 не образует таких конфигураций, и некоторые автоматы такого класса являются Тьюринг-полными и могут выполнять произвольные вычисления.
        Пример работы такого автомата можно увидеть на рисунке~\ref{fig:wolf110}.
        Хорошо различимы как стабильные зоны, так и движущаяся область сложных взаимодействий.
\end{itemize}

\begin{figure}[!h]
\caption{Иллюстрация работы клеточного автомата Вольфрама 110}\label{fig:wolf110}
\includegraphics[width=15cm]{graphics/rule110_e27.png}
\end{figure}

Вольфрам доказал, что клеточные автоматы, несмотря на свою кажущуюся простоту, могут моделировать поведение произвольно сложных систем.
Сейчас они применяются в широком круге областей, от биологии и лингвистики до физики и теории хаоса.
Также клеточные автоматы используются и в информационных технологиях, в том числе и в криптографии~\cite{zhu17}.

В криптографии исследования клеточных автоматов начались с генераторов псевдослучайных последовательностей.
Генераторы псевдослучайных последовательностей, основанные на одномерных клеточных автоматах не получили широкого распространения,
так как свойства клеточных автоматов, обеспечивающие криптографическую стойкость результирующих последовательностей,
изучены недостаточно.
Однако потоковые шифры, основанные на генераторах псевдослучайных последовательностей на двумерных и обобщённых
клеточных автоматах, показывают производительность в разы быстрее традиционных аналогов~\cite{zhu17_2}.
Также существуют исследования по применению клеточных автоматов для блочных шифров в сетях Фейстеля, имитовставок,
криптосистем с открытым ключом и т.д.

Быстродействие в таких системах достигается за счёт независимого вычисления значений каждой ячейки клеточного автомата.
Эта особенность позволяет проводить вычисление значений параллельно - с использованием независимых логических элементов или ядер процессора.
С помощью клеточных автоматов можно создавать высокоэффективные относительно и времени, и количества элементов для аппаратной реализации различных алгоритмов.
Существуют и исследования по использованию клеточных автоматов для ускорения алгоритмов возведения в степень~\cite{ku02}.
Например, к клеточному автомату можно свести алгоритм Монтгомери~\cite{jeo07}, упомянутый в предыдущей главе.

\section{Параллелизация алгоритма Монтгомери}\label{sec:paramont}

В алгоритме возведения в степень Монтгомери на шагах 4 и 5 в вычислении двух значений
$m(x)$ и $c(x)$ существует общий шаг~\cite{ku04} - умножение на мультипликативно обратное к $r$:
\begin{gather*}
  \text{MMM}(\overline{m}(x), \overline{c}(x)) = \overline{m}(x)\overline{c}(x)r^{-1} \pmod{n(x)}\\
  \text{MMM}(\overline{m}(x), \overline{m}(x)) = \overline{m}(x)\overline{m}(x)r^{-1} \pmod{n(x)}\\
\end{gather*}
Вычисление значения $\overline{m}(x)r^{-1}$ единожды и параллельное вычисление квадрата и произведения
позволяет значительно ускорить выполнение алгоритма возведения в степень:
\begin{lstlisting}[breaklines=true, mathescape=true]
    $\textit{Вход}: ~\overline{m}(x), ~\overline{c}(x), ~n(x)$
    $\textit{Выход}: ~M(x) = \text{MMM}(\overline{m}(x), \overline{c}(x)),
    ~S(x) = \text{MMM}( \overline{m}(x), \overline{m}(x))$
    1: $t(x)= \overline{m}(x)$
    2: $M(x)=0,~S(x)=0$
    3: for i = k-1 to 0
    4:   $t(x) = (t(x) + t_0 n(x))/x$
    5:   $M(x)= M(x)+t(x)\overline{c}_i,$ $S(x) = S(x)+ t(x)\overline{m}_i$
\end{lstlisting}

Этот алгоритм может быть описан и реализован с помощью клеточных автоматов.
На шаге 4 в алгоритме для деления на $x$ используется операция побитового сдвига вправо.
Такая операция может быть описана с помощью элементарного клеточного автомата 240:
\begin{table}[h]
    \begin{tabular}{ l l l l l l l l l }
    Состояние ячейки и соседей: & 111 & 110 & 101 & 100 & 011 & 010 & 001 & 000 \\
    Следующее состояние: & ~1 & ~1 & ~1 & ~1 & ~0 & ~0 & ~0 & ~0 \\
    \end{tabular}
\end{table}

Как видно из рисунка~\ref{fig:cell}, за такт работы этого автомата значения во всех регистрах циклически сдвигаются на бит вправо.
\begin{figure}[!h]
    \caption{Такт работы клеточного автомата с правилом 240}\label{fig:cell}
    \begin{tikzpicture}[shorten >=1pt,->]

        \tikzstyle{vertex}=[circle,fill=black!25,minimum size=30pt,inner sep=0pt]

        \foreach \text/\name in {t_{k-1}/1, t_{k-2}/2, \dots/3, t_1/4, t_0/5}
            \node[vertex] (G-\name) at (\name*2, 0) {$\text$};

        \foreach \from/\to in {1/2,2/3,3/4,3/4,4/5}
            \draw (G-\from) -- (G-\to);

        \draw (G-5) .. controls +(-150:2cm) and +(-30:2cm) .. (G-1);

    \end{tikzpicture}
\end{figure}
Структура шага 4 на клеточном автомате изображена на рисунке~\ref{fig:step4}.
\begin{figure}[!b]
    \caption{Вычисление $t(x) = (t(x) + t_0 n(x))/x$ с помощью клеточного автомата}\label{fig:step4}
    \includegraphics[width=0.9\textwidth]{graphics/step4.pdf}
\end{figure}
Результат из регистра $t$ направляется на вычисление $S$ и $M$.

Данный алгоритм параллельного возведения в квадрат и перемножения позволяет
произвести обе операции за количество тактов, равное длине неприводимого многочлена в битах.
Также он требует меньше ячеек памяти и логических элементов, чем сравнимые аналоги~\cite{ku04}.
Исследований по программным реализациям данного алгоритма и сравнению его производительности с другими вариациями не проводилось.

Алгоритм параллельного возведения в квадрат и перемножения с помощью клеточных автоматов позволяет создать
оптимизированную версию алгоритма возведения в степень Монтгомери:\\\\
\begin{lstlisting}[breaklines=true, mathescape=true]
    $\textit{Вход}: ~m(x), ~e, ~n(x), ~r^2 = r(x) \cdot r(x) \pmod{n(x)}$
    $\textit{Выход}:~c(x) = m(x)^e \pmod{n(x)}$
    1: $\overline{m}(x) = \text{MMM}(m(x), r^2)$
    2: $\overline{c}(x) = \text{MMM}(1, r^2)$
    3: for i = 0 to k-1
    4:   if $e_i$ == 1: $(\overline{c}(x),\overline{m}(x))  = \text{MMMS}( \overline{m}(x), \overline{c}(x))$
    5:   else: $\overline{m}(x) = \text{MMM}( \overline{m}(x), \overline{m}(x))$
    6: $c(x) = \text{MMM}( \overline{c}(x), 1)$
\end{lstlisting}
Эта версия получает значительный выигрыш в скорости на единицах в степени, так как вместо двух
умножений Монтгомери выполняется одна параллельная операция.
Так как степень в идеале - случайное число, единиц в степени в среднем будет около половины,
что предполагает выигрыш в скорости работы около 30\% (в идеальном случае).
Также при условии выполнения двух операций за то же время, что и одно умножение, этот алгоритм будет выполняться за постоянное время.
Классическое умножение Монтгомери имеет зависимость между временем исполнения и весом Хемминга степени.

Таким образом, алгоритм возведения в степень Монтгомери, оптимизированный с помощью клеточных автоматов не только даёт
прирост в скорости по сравнению с другими алгоритмами возведения в степень по модулю, но и предоставляет возможности
для аппаратной реализации и важные с точки зрения безопасности свойства.

\finishrelatedwork
\chapterconclusion

В рамках данной главы были рассмотрены теоретические основы и концепции, необходимые для понимания принципов работы алгоритма Диффи-Хеллмана.
Также были представлены алгоритмы, которые используются для возведения в степень по модулю в существующих криптографических системах:
классический алгоритм быстрого возведения в степень по модулю <<слева направо>> и алгоритм Монтгомери.
Была рассмотрена оптимизация алгоритма Монтгомери с помощью клеточных автоматов, которая использовалась для предложенной
в работе модификации алгоритма Диффи-Хеллмана.

Также в демонстрационных целях была разработана библиотека для визуализации клеточных автоматов.

\chapter{Требования к реализациям криптографических систем}

Информационные технологии и, в частности, криптография, были подвержены жёсткому регулированию с самого начала их развития.
Сразу после конца Второй Мировой войны в США и многих других странах были разработаны правила контроля экспорта
технологий, которые могут иметь <<двойное назначение>>, то есть могут применяться как в мирных, так и в военных целях.
Криптография попала под эти ограничения как военная технология.

Развитие финансовой сферы и разработка стандарта Data Encryption Standard привело к серьёзным проблемам с контролем экспорта.
С ростом популярности персональных компьютеров эти проблемы привлекли внимание широкой публики.
Для защиты транзакций по кредитным картам в 1990-ые годы использовалась в основном технология Secure Socket Layer (SSL).
SSL использовала шифр с длиной ключа 128 бит, но для экспорта были разрешены только ключи в 40 бит.
Для выполнения этих требований в <<экспортном>> SSL в открытую передавались 88 бит ключа.
Результирующие ключи в 40 бит могли быть взломаны за несколько дней даже на персональном компьютере тех времён~\cite{lev01}.
Это делало транзакции с зарубежными партнёрами практически незащищёнными.
Из-за сложности заполучить <<домашнюю>> версию SSL многие пользователи внутри США тоже использовали небезопасную
<<экспортную>> версию, что лишало алгоритм смысла.

После долгих судебных процессов криптография была переведена из категории военных технологий в категорию коммерческих,
ограничения сильно смягчились.
Также в 2000 году было решено не применять регуляторные практики для технологий к программному обеспечению,
что дало толчок к развитию и экспорту как проприетарного, так и открытого программного обеспечения для криптографии.

\section{Уязвимости экспортной криптографии}\label{sec:logjam}

Ограничение в 40 бит действовало для систем с симметричным ключом.
Асимметричным системам наподобие алгоритма Диффи-Хеллмана необходима большая длина ключа для эквивалентного уровня криптографической стойкости.
Симметричному ключу в 40 бит примерно эквивалентны асимметричные ключи в 512 бит.
Такие ключи (и необходимые для них неприводимые многочлены) по незнанию или по неосторожности поддерживались во многих системах ещё
долгое время после отмены регуляторных ограничений.

На 2015 год около 10 процентов самых популярных сайтов поддерживали шифрование соединения по устаревшему <<экспортному>> стандарту.
Так как подбор неприводимых многочленов для алгоритма Диффи-Хеллмана требует обширных математических изысканий,
в основном используется общеизвестный и довольно узкий набор неприводимых многочленов, предоставляемый
регуляторными органами или крупными провайдерами наподобие Apache.

Крупный резонанс в 2015 году вызвала атака Logjam.
Главный компонент этой атаки - алгоритм на основе предварительных вычислений с помощью метода решета числового поля,
которые для 512-битных групп занимали около недели, позволяющий вычислять дискретные логарифмы за 70 секунд~\cite{adr15}.
Перед обменом ключами происходит согласование группы, которая будет использоваться.
Второй компонент этой атаки - это принуждение сервера использовать именно ту группу, для которой проведены предварительные вычисления.
Если сервер использует один и тот же секретный ключ для всех клиентов, это позволяет скомпроментировать все его соединения, использующие ту же группу.
Даже если сервер не поддерживает конкретную группу, всего их в широком использовании, как уже упоминалось, немного.
Например, 92\% сайтов, поддерживавших <<экспортные>> группы в 2015, поддерживали всего две группы.

После публикации статьи, описывающей данную атаку, поддержку <<экспортной>> криптографии начали активно прекращать.
Тем не менее, атака Logjam позволяет компроментировать не только группы в 512 бит.
Сложность необходимых предварительных вычислений растёт сверхполиномиально с длиной группы, но ещё в 2015 исследователи считали,
что даже группы в 1024 бита уже ненадёжны.
Таким образом, инженерное сообщество столкнулось с необходимостью ужесточения стандартов и удлиннения ключей шифрования.

\section{Требования к реализациям протоколов обмена ключами}\label{sec:IETF}

Алгоритм Диффи-Хеллмана использовался как опция для защищённого обмена ключами в протоколе Secure Sockets Layer (SSL).
В протоколе SSL и основанном на нём протоколе Transport Layer Security (TLS) широко используются центры сертификации
(Certificate Authority, CA), которые подписывают открытые ключи серверов и сайтов.
В классическом виде алгоритм Диффи-Хеллмана уязвим к атакам "человек посередине", поэтому в протоколе были
обозначены три варианта алгоритма, два из которых используют подписи.

Первый вариант - \textbf{анонимный}, или классический. Секретные ключи в таком варианте генерируются с помощью публичных
ключей, которые не подписаны никаким центром сертификации.
Такой вариант изначально предлагался в статье "New Directions in Cryptography" и не считается надёжным сам по себе,
так как при перехвате всех коммуникаций атакующий может подставить свои ключи, скомпроментировав безопасность шифрования.

Второй вариант - \textbf{фиксированный}. Для генерации секретного ключа сервером используется заранее известный публичный ключ
сервера или сайта, копия которого хранится у центра сертификации.
Такой метод позволяет генерировать публичные ключи заранее и хранить их для повторного использования со множеством клиентов или серверов.
Главная проблема такого метода - компроментирование всего одного публичного ключа даст атакующему доступ
ко всем коммуникациям, которые использовали или будут использовать этот ключ.
Например, при компроментации публичного ключа сервера становится известен его закрытый ключ, и ключ
симметричного шифрования можно получить, просто перехватив открытый ключ клиента.
Такая проблема не имела бы значения, если компроментация публичного ключа была бы невозможна.
Но некоторые ключи шифрования, которые на данный момент находятся в широком использовании, могут быть скомпроментированы
за довольно короткое время при наличии достаточных ресурсов.

Эта проблема привела к появлению третьего варианта - \textbf{эфемерного}.
Он использует временные публичные ключи, которые генерируются для каждой сессии.
Эти публичные ключи должны быть подписаны открытой подписью сервера, которую может подтвердить
центр сертификации.
Таким образом, при компроментации какого-либо ключа для определённой сессии атакующий не может получить
доступ к другим коммуникациям.
Это свойство называется <<совершенная прямая секретность>>.

На основе протокола SSL был создан протокол TLS.
После прекращения поддержки версий 1.0 и 1.1~\cite{mor20} актуальными остаются версии 1.2~\cite{rfc5246} и 1.3~\cite{rfc8446}.
В версии 1.2 разрешены только фиксированный и эфемерный вариант алгоритма Диффи-Хеллмана, в 1.3 - только эфемерный вариант.
Также в TLS 1.3 разрешены только модификации алгоритма, основанные на конечных полях или эллиптических кривых.

Протокол TLS описывается и поддерживается Инженерным советом Интернета (IETF).
IETF выпускает стандарты, в которых содержатся рекомендации для реализаций протоколов,
математически безопасные группы, которые рекомендуется использовать в реализациях.
Рекомендации IETF имеют несколько уровней от MUST (обязательно рекомендуется) до MUST NOT (абсолютно нельзя).
Обмен ключами регламентирован в протоколе <<Internet Key Exchange v2>>.
На 2005 год (и в TLS 1.2) допустимыми считались группы в 768 бит~\cite{rfc4307}, но на 2017 год
такие группы, цитата, <<могут быть взломаны за несколько часов с помощью широко доступного
в продаже оборудования и не дают абсолютно никакой безопасности>>~\cite{rfc8247}.
Даже группы в 1536 бит получили статус <<не рекомендуется>>.
Минимальная длина группы, которую на данный момент рекомендуется использовать для
алгоритма Диффи-Хеллмана на конечных полях - это 2048 бит.

Устаревшие стандарты IETF довольно долго поддерживаются даже после выхода следующих версий для поддержки обратной совместимости.
Оригинальный SSL 2.0 запретили только в 2011 году, несмотря на то, что стандарт TLS появился в 1999.
Но для обеспечения безопасности всегда необходимо следовать последним рекомендациям.

\chapterconclusion

В рамках данной главы были рассмотрены различные законы и стандарты, регулирующие криптографию и применение алгоритма
Диффи-Хеллмана.
Последний стандарт TLS 1.3 представил достаточно много новых требований, которые делают невозможным использование
различных оптимизаций из предыдущих версий протокола: больше нельзя повторно использовать публичные ключи, допустимые
группы, используемые в протоколе, стали длиннее и т.д.
Соответственно, как никогда важно стало ускорение работы алгоритма Диффи-Хеллмана.
Оптимизации, наподобие рассматриваемых в данной работе, позволят поддерживать допустимый уровень безопасности
без ущерба для пользовательского опыта.

\chapter{Имплементация и тестирование модификации алгоритма Диффи-Хелмана с использованием клеточных автоматов}

В рамках данной работы была разработана библиотека для арифметики в конечных полях на языке Python.
В библиотеке было реализовано несколько вариаций алгоритмов возведения в степень в конечных полях.
С использованием этой библиотеки были реализованы различные модификации алгоритма Диффи-Хеллмана и
проведено сравнительное тестирование производительности модификаций алгоритма.

\section{Выбор языка программирования}\label{sec:prog}

Для реализации был выбран язык Python версии 3.7.
Данный язык достаточно прост в освоении и использовании, и идеально подходит для работ в обучающих целях.
В существующих криптографических библиотеках~\cite{openssl} используются более сложные представления чисел,
операции умножения и возведения в степень в которых проводятся не побитово, а со "словами", то есть по несколько бит разом.

Ключевая для данной задачи особенность языка Python - это встроенная в язык работа со сколь угодно большими числами.
В языке C, например, число может занимать максимум 4 байта, а неприводимые многочлены, которые использовались
в данной работе, занимают до 1 килобайта.

%Выбор реализации длинной арифметики - задача на отдельную научную работу.
Существующие реализации  в основном оптимизированы для стандартной арифметики, и переопределение операций
сложения и умножения на аналогичные для конечных полей требует обширных знаний и специфических навыков.
Другие реализации~\cite{pri16} приспособлены для работы в полях GF($p^n$), что не позволяет использовать
некоторые особенности рассматриваемых алгоритмов.

Так как данная работа сфокусирована на сравнительном тестировании производительности, решено было с нуля
реализовать все необходимые классы и функции.
Таким образом разница в производительности между модификациями алгоритма Диффи-Хеллмана появляется исключительно
из-за свойств выбранного алгоритма возведения в степень.

Алгоритмы, реализованные в данной библиотеке за счёт вышеобозначенных свойств языка легко <<перевести>> и приспособить для
использования в любой другой реализации.
Также библиотека может использоваться в обучающих целях, например, для образца реализации стандарта TLS 1.3.

\section{Описание реализации}\label{sec:impl}

Для представления многочленов в конечном поле GF($2^k$) использовались стандартные числовые переменные языка Python.
Массив бит такой переменной представляет массив $a_{k-1} \dots a_0$ для многочлена
$a(x) = a_{k-1} x^{k-1} + a_{k-2} x^{k-2} \dots a_1 x + a_0$.
Такое представление позволяет получить значительный прирост в скорости вычислений~\cite{mau15}.

Был создан класс <<Конечное поле>>, в который как параметр передаётся неприводимый многочлен.
В рамках данного класса операция сложения переопределена как побитовое исключающее ИЛИ, а операция умножения
реализована с помощью модифицированного алгоритма <<крестьянского>> умножения, представленного в главе~\ref{sec:oper}.
С его помощью были реализованы алгоритмы бинарного возведения в степень "слева направо" и "справа налево".

Также была реализована вариация расширенного алгоритма Евклида - алгоритм Бланкеншипа - для вычисления мультипликативно обратных.
На его основе был реализован алгоритм преобразования Монтгомери, который не использовался в данной работе.
Преобразование реализует перевод чисел в форму Монтгомери и обратно, но в работе такое преобразование реализовано через
умножение Монтгомери на $r^2$ и единицу, соответственно.

Умножение и возведение в степень Монтгомери основывались на алгоритмических описаниях в главе~\ref{sec:mont}.
Алгоритм параллельного возведения в квадрат и умножения на клеточных автоматах и оптимизированный с его помощью алгоритм Монтгомери
основывались на описаниях в главе~\ref{sec:paramont}.

\section{Методология тестирования производительности}\label{sec:meth}

Для тестирования производительности было использовано два списка неприводимых многочленов.
Первый - это список со степенями $k$ от 2 до 32~\cite{par17}.
Он включает в том числе многочлен AES $x^8+x^4+x^3+x+1$.
Этот набор использовался скорее в демонстрационных и отладочных целях.

Второй список - это комплекс неприводимых многочленов из различных стандартов IETF~\cite{rfc2412, rfc3526, rfc7296, rfc7919}.
Все эти многочлены были подобраны с учётом множества математических и криптографических критериев и широко использовались
или используются на реальных системах.
В тестирование включены многочлены в 768, 1024 и 1536 бит, которые сравнительно недавно объявили <<не рекомендуемыми>>~\cite{rfc8247}.
Это позволяет понять, какого изменения в скорости работы стоит ожидать при переходе на многочлены, рекомендованные последними стандартами.
Также это позволяет показать, что серьёзных потерь в скорости можно избежать с помощью использования оптимизации, рассматриваемой в работе.

Во всех тестах использовались три различных алгоритма возведения в степень в конечных полях:
\begin{enumerate}
  \item По алгоритму <<слева направо>>.
  \item По алгоритму Монтгомери.
  \item По алгоритму Монтгомери, оптимизированному с помощью клеточных автоматов.
\end{enumerate}

Тестирование производилось на ЭВМ с процессором AMD Threadripper 3960X с 24 ядрами и тактовой частотой 3.8-4.2 гигагерц.
Высокое количество ядер позволило проводить все наборы тестов одновременно.

В первом наборе тестов использовались неприводимые многочлены из первого списка.
Тестировалась производительность именно алгоритма возведения в степень.
Так как время работы для одного возведения в степень крайне мало, для каждого теста проводилось 10000 операций для
каждого алгоритма.
Случайным образом генерировались 10000 чисел M и степень E:
\[M, E, i = 1~to~10000:~r(x)/x^2 \leq m_i, E < r(x)/x\]
Затем для каждого алгоритма замерялось время на 10000 операций возведения в степень.
Для данного теста было проведено 760 циклов тестирования.

Для второго набора тестов использовался второй список неприводимых многочленов.
Такой тест более коррелирует с реальными случаями применений алгоритма.
Также случайным образом генерировались число и степень:
\[m, E:~r(x)/x^2 \leq m, E < r(x)/x\]
И измерялось время на операцию возведения в степень.
Для данного теста было проведено 200 циклов тестирования.

В третьем наборе тестов использовался полный набор операций, необходимый для получения секретного ключа по алгоритму Диффи-Хеллмана.
Выбиралось два случайных числа:
\[a, b:~r(x)/x^2 \leq a,b < r(x)/x\]
И вычислялись открытые ключи и дважды - секретный ключ: $g^a, g^b, (g^a)^b, (g^b)^a$.
Генератор $g = 2$ был взят из рекомендаций в стандартах IETF.
Такой тест потенциально благоприятно предрасположен к алгоритмам Монтгомери, так как необходимые характеристики конечного поля
$k, r, r^2 \pmod{n(x)}$ сохраняются между вычислениями без необходимости пересчёта.
Но положительный эффект скорее всего пренебрежимо мал для достаточно больших многочленов.
Также он может компенсироваться более быстрой работой <<крестьянского>> умножения на небольших числах.
Умножение Монтгомери проходит все биты числа до $k$, тогда как <<крестьянское>> умножение может завершиться заранее.
Для данного теста было проведено 60 циклов тестирования.

Графики, таблицы и описание результатов тестирования представлены в следующей главе.

\section{Результаты тестирования производительности}\label{sec:results}

\begin{figure}[!h]
\caption{Сравнение производительности для 10000 операций возведения в степень}\label{fig:res}
\input{graphics/results_ru.pgf}
\end{figure}

На рисунке~\ref{fig:res} представлены результаты первого набора тестов - сравнение производительности различных
модификаций алгоритма возведения в степень для 10000 операций на небольших многочленах.
Как и предполагалось, на небольших многочленах стандартный алгоритм <<слева направо>> выполняется быстрее из-за
необходимости перевода чисел в форму Монтгомери и обратно.
Но уже на многочленах длиной более 6 бит для параллельной модификации и 8 бит для стандартного алгоритма Монтгомери
оптимизированные версии имеют преимущество.
Такой результат наглядно демонстрирует преимущество умножения и возведения в степень Монтгомери.

\begin{figure}[!h]
\caption{Сравнение производительности для операции возведения в степень}\label{fig:res_bignum}
\input{graphics/results_bignum_ru.pgf}
\end{figure}

На рисунке~\ref{fig:res_bignum} представлены результаты второго набора тестов - сравнение производительности различных
модификаций алгоритма возведения в степень для одной операции на многочленах из рекомендаций IETF.
Как видно из графика, оптимизированная с помощью клеточных автоматов модификация алгоритма Монтгомери
вычисляет экспоненты с многочленами в 4 килобита почти так же быстро, как стандартный метод <<слева направо>> с
многочленами в 3 килобита.
Это значит, что такой метод может дать значительный прирост в длине ключей и, следовательно, безопасности практически
без ущерба для скорости.
В сравнении со стандартным возведением в степень Монтгомери, который используется в широко применяемых
криптографических библиотеках~\cite{openssl}, преимущество меньше, но всё ещё значительно - от 20 до 25\%.

\begin{figure}[!h]
\caption{Сравнение производительности для полного алгоритма Диффи-Хеллмана}\label{fig:res_dhke}
\input{graphics/results_dhke_ru.pgf}
\end{figure}

Результаты третьего набора тестов продемонстрированы на рисунках~\ref{fig:res_dhke} и~\ref{fig:res_dhke_per},
а также в таблице~\ref{tab:dhke}.
Форма графика на рисунке~\ref{fig:res_dhke} практически повторяет график на рисунке~\ref{fig:res_bignum}.
Сравнение этих графиков позволяет проследить следующую зависимость: время на получение секретного ключа (что
требует четыре операции возведения в степень) для алгоритма <<слева направо>> практически ровно в четыре раза
больше, чем для одной операции (420 и 130 секунд).
Для алгоритмов Монтгомери же это время возросло чуть меньше - примерно в 3.9 раза.
Это различие вытекает из сохранения коэффициентов конечного поля $k, r, r^2 \pmod{n(x)}$ между вычислениями.
Эти коэффициенты не зависят от публичного ключа пользователя, только от неприводимого многочлена.
Таким образом, это преимущество работает даже в эфемерной версии алгоритма Диффи-Хеллмана.


\begin{figure}[!h]
\caption{Относительное сравнение производительности для полного алгоритма Диффи-Хеллмана}\label{fig:res_dhke_per}
\input{graphics/results_dhke_percent_ru.pgf}
\end{figure}

На рисунке~\ref{fig:res_dhke_per} представлены относительные результаты производительности модификаций алгоритма Диффи-Хеллмана.
За 100 процентов на данном графике взято время алгоритма <<слева направо>>.
Как видно из графика, даже стандартный алгоритм Монтгомери даёт преимущество около 20\%, а оптимизированная с помощью клеточных
автоматов модификация алгоритма Монтгомери позволяет получить прирост в скорости работы до 40\%.

В таблице~\ref{tab:dhke} представлены усреднённые времена работы модификаций алгоритма Диффи-Хеллмана, по которым
строились графики на рисунках~\ref{fig:res_dhke} и~\ref{fig:res_dhke_per}.
Таблица позволяет отчётливо увидеть, что оптимизированная с помощью клеточных автоматов модификация алгоритма
Диффи-Хеллмана позволяет увеличить длину ключей с, например, более непригодных 1536 бит до безопасных 2048 бит при замене
модификации алгоритма Диффи-Хеллмана, основанной на стандартном алгоритме возведения в степень <<слева направо>>.

\begin{table}[h]
\begin{tabular}{ | c | c | c | c | }
\hline
\backslashbox{Степень}{Алгоритм} &
\vtop{\hbox{\strut Алгоритм}\hbox{\strut <<слева направо>>}} &
\vtop{\hbox{\strut Алгоритм}\hbox{\strut Монтгомери}} &
\vtop{\hbox{\strut Параллельный алг.}\hbox{\strut Монтгомери}} \\
\hline
768  & 1.40  & 1.07  & 0.88 \\
1024  & 2.48  & 2.07  & 1.71 \\
1536  & 6.10  & 4.96  & 4.08 \\
2048  & 11.60  & 9.48  & 7.73 \\
3072  & 31.11  & 25.15  & 20.28 \\
4096  & 81.04  & 63.40  & 50.55 \\
6144  & 216.21  & 175.54  & 141.36 \\
8192  & 460.39  & 378.58  & 304.74 \\
\hline
\end{tabular}
\caption{Усреднённое время работы модификаций алгоритма Диффи-Хеллмана}\label{tab:dhke}
\end{table}

Стоит повторить, что данная реализация не предназначена для практических применений.
Она создавалась для обучающих и демонстрационных целей.
Для сравнительного тестирования производительности длительность обмена ключей в пять минут приемлема, но
широко применяемые реализации производят подобные вычисления несоизмеримо быстрее.
Цель данных тестов - продемонстрировать, что разрабатываемая модификация алгоритма даёт преимущества в скорости работы
по сравнению с вариантами, используемыми в распространённых библиотеках.
Достижение этой цели доказывает целесообразность <<перевода>> и адаптации этой модификации для, к примеру, OpenSSL~\cite{openssl}.
В данном проекте уже используется возведение в степень Монтгомери, и введение разрабатываемой модификации потребует
минимальных изменений.

\chapterconclusion

В рамках данной главы была разработана открытая библиотека для вычислений в конечных полях на языке Python,
которая была использована для сравнительного тестирования производительности разработанной модификации
алгоритма Диффи-Хеллмана с вариантами, которые используются в существующих реализациях.
Тестирование показало, что разработанная модификация алгоритма, оптимизированная с помощью клеточных автоматов даёт
прирост в скорости работы алгоритма от 20 до 40\%.
Такой прирост позволяет либо ускорить операцию получения секретного ключа, либо увеличить длину ключей практически без
потерь в скорости, что как никогда важно в свете новых требований TLS 1.3.

Разработанная библиотека может использоваться для демонстрационных реализаций других шифров на конечных полях GF($2^k$):
AES, RSA, алгоритма Эль-Гамаля и т.д.
Она распространяется по лицензии GPLv2.

\startconclusionpage

В ходе данной работы была разработана модификация алгоритма Диффи-Хеллмана, оптимизированная с помощью клеточных автоматов.
Для анализа актуальности работы были рассмотрены как рекомендации для реализаций криптографических систем,
так и практические имплементации алгоритма Диффи-Хеллмана.

Разработанная модификация алгоритма может быть использована для ускорения процесса обмена ключами до 40\% или для
увеличения безопасности последующего шифрования с помощью удлиннения ключей без значительного замедления.
Модификация может быть реализована как программно, так и аппаратно с помощью логических схем на основе клеточных автоматов.

Для тестирования разработанной модификации также была создана открытая библиотека для арифметики в конечных полях на языке Python.
Данная библиотека может быть использована для последующего включения модификации в состав широко используемых
криптографических пакетов, например, OpenSSL и основанного на нём OpenSSH.
Также в демонстрационных целях была разработана библиотека для визуализации работы клеточных автоматов.

Подобные модификации могут быть разработаны для других алгоритмов на основе операции возведения в степень в конечных полях,
например, для схемы Эль-Гамаля.
Также возможна реализация подобных модификаций для представлений Монтгомери на эллиптических кривых.

\printmainbibliography

\end{document}
